<!DOCTYPE html>
<html>
  <head>
  
    <title>Scalable Cloud Architecture on Platform Level</title>


    <link rel="stylesheet" href="stylesheets/lattex.css">    
    <script src="javascripts/lattex.js"></script>

    <script>
      var conf = { 
        lol: true,
        cat: "loooong"
        };
    </script>



  </head>
  
    
  <body>

    <header>
      <h1 data-lattex="title"></h1>

      <address>
        Matti Paksula
      </address>
      
    </header>
      
    <nav></nav>
    
    
    <article>
		<h1 data-lattex="title"></h1>
		
		<section>
        	<h1>Introduction</h1>
        
        	<pre>
	       		Cloud Computing has recently gained huge popularity in business, academia and everyday peoples lives.
	        </pre>

			<section>
				<h1>Research Questions</h1>
		
				<pre>The main research questions that this thesis provides answers to are..</pre>
			</section>

			<section>
				<h1>Scope of The Thesis</h1>
		
				<pre>PaaS</pre>
			</section>
		
		
			<section>
				<h1>Structure of The Thesis</h1>
		
				<pre>
					Cloud definition
			
					Scalability
			
					Measuring
			
					Problems
				</pre>
			</section>
		
		</section>
              
              
              
		<section>
        	<h1>Background for Cloud Computing</h1>
      
        	<pre>
				What is paradigm

				Cloud computing is the latest paradigm shift in the history of computing.  It draws technical background and principles from all computing paradigms since 1960's, starting from the early time-sharing systems in the 1960's to latest web packaged software of the late 1990's.  As a composition of old models and principles it is sometimes also seen as a buzzword or umbrella term, not an actual computing paradigm.  In the next sections the previous paradigms with their supporting architectures are briefly explored to identify the background from what the cloud is composed of.  Then the attributes that are unique to cloud computing of are presented justifying cloud computing as a true paradigm shift.
	        </pre>
      
      
        <section>
        	<h1>Pre-networking Computing</h1>
        
          	<pre>
				In the early days of computing, computers were physically big, complicated machines, that were used for specialized tasks.  These tasks included calculations for roofs, airplane wing designs and such tasks that were regularry performed by <em>"human computers"</em>.  When a calculation was to be made, one needed physical access to the machine and also deep knowledge of how to operate the machine itself.  As the machines were not mass produced, the price tag for a single machine was very high <cite>zuse</cite>.
			
				Later the computers become more generic in their ability to solve different problems.  Computers were still costly, and to get better value of for the investment, developments in getting the utilization rate of a computing resource up was under research.
			
				This time introduced a concept called <em>multitenancy</em>.  This means that a single resource hosts different users with different needs.  <em>Time-sharing systems</em> allowed users to utilize one powerful centralized computer at the same time.   This reduced the costs of computing, as the organizations could share one big system.  Each user could log on and load their own program to be run simultaneously for a fraction of time.  Usage was accounted and billed by the actual time and resourced used [TimeSharing64].  These systems evolved and became more standardized.  Centralized mainframe systems were accessed with wired remote terminals resembling the computing we know today.

				As the costs of manufacturing computers reduced, the computers became personal.  This also gave a boost to the software industry as each desktop computer needed its own, physical copy of the software package, so called "shrink-wrapped software".  Users became responsible of maintaining their hardware, software and the data associated with it <cite>CloudComputing</cite>.  
	          </pre>
			</section>


			<section>
	        	<h1>Networked Computing</h1>
         
				<pre>
					The networked computing as we know it today, evolved from terminal-computer communication.  Large networks already existed between large centralized mainframes, but as the need for computer-computer interconnectivity grew, technology called Ethernet become successfull.
				
					Ethernet allowed computers to be networked together without need for computers themselves to provide communication.  Probalisitic delivery of the network provided solid base for the growth of the largest unreliable network, the Internet.  The design principles of the Ethernet still influence architectural design patterns of modern web applications <cite>Ethernet</cite>.
					
				</pre>
			
			
	        	<section>
					<h1>Client-Server</h1>
				
					<pre>
						During the 1980's networking enabled networked desktops to communicate with a shared networked resource, a server.  Desktops became workstations that could store their data also on the shared server, and their software could utilize the resources available on the server for computation.  This client-server architecture made working in groups more efficient and reduced the maintenance required by user, as the updates could be deployed in the server and the shared data could be backed up from one centralized location [ClientServer96, CloudComputing08].

						When the networks became more established during the 1990's, visions of cost efficient and mainly maintenance free client computer were largely discussed and supported by major companies of the hardware industry, like the IBM.  These thin-clients would only provide basic hardware and make use of the software loaded from a centralized server.  Due limited network speeds and availability of reliable network links this model did not become very popular [InTheClouds07].
			
						During this era, the Relational Database Management Systems (RDBMS) also became a popular solution for enterprise data management.  RDBMSes provided and still provide all-purpose structured storage for data with querying abilities [ClientServer96].
					</pre>
				</section>
			

				<section>
					<h1>Software Packaged in the Web</h1>

					<pre>
					The success of the Internet in the late 1990's and early 2000's opened a new industry for software packaged in the web instead of shrink-wrap.  Familiar desktop software such as simple word processing, shared calendars, intranets and other groupware are delivered through the web browser liberating the user from installation or maintenance [Cusumano10].
					
					From an end users point of view, this step usually is as cloud as it gets.  Users have accepted that data resides on the server and gain many advantages from it.  The software that is delivered as a web application is however <em>not</em> part of the cloud computing, because it does not satisfy the attributes that will be explored in the last section of this chapter.
					</pre>
				</section>


				<section>
					<h1>Application Service Providers</h1>

					<pre>
						An organization can outsource their software to a separate company to gain savings of operationing costs and better the focus on their own business.  While this <em>one to one</em> hosting of own software on external provider is still used, majority of the software is provided as service in <em>one to many</em> fashion.
					
						Application Service Provider (ASP) a software that is accessible through network, most commonly the Internet, is provided for many different customers from a data center.  As the same software and infrastructure can be used in together with isolation of the data this brings many advantages for clients.
					
						<em>Savings</em> in upfront and total costs are possible, as service is paid on monthly or per user basis. <em>Scalability</em> and better <em>service level</em> is achieved as the providers business model needs to focus on service availablity.  This is usually enforced with service level agreements (SLAs).  Also, the expertice needed in <em>maintenance</em> are not needed inside the customer.
					
						This model of using software essentially converts traditional thinking of software products in to a delivery service, where the software is constantly being delivered until the service is cancelled <cite>asp</cite>.					
					</pre>
				</section>

			
				<section>
					<h1>Service-Oriented Architectures</h1>

					<pre>
					In Service-Oriented Architectures (SOA) the architecture consists of loosely coupled individual services.  Each of the services can expose the functionality it provides by publishing a description.  This description can be given as Web Services Description Language (WSDL), that is based on XML.  Another option is not to publish a description, but to use common standards and conventions, like Representational State Transfer (REST).  When a service design follows commonly accepted standards, it is fast to other services to start using them.
					
					The main use case for SOA is that services can be composed of many autonomous services.  Composing services of smaller components has advantages in maintainability and scalability.  The online retailer Amazon.com was one of the first web services, who renewed their internal architecture from monolithic service to a set distributed service-oriented services.  For example the front page of amazon.com can call more than 100 services to construct the page <cite>vogels</cite>.
					</pre>
				</section>

			
				<section>
					<h1>Autonomic Computing</h1>
					
					<pre>
						Distributed large scale systems add complexity to the overall service architecture.  In 2001 IBM announced Autonomic Computing Initiative that derives its name from biological autonomic nervous system.  In the same sense as nervous system adjusts for example the heart rate according to changes in the body, the autonomic computing environment would adjust its resources constantly freeing up administrative personel to focus on higher level goals.  Other initiatives are presented like Adaptive Enterprise (HP) and Dynamic Systems (Microsoft) <cite>autonomic_vision</cite>
						
						<cite>autonomic_research</cite>
						
						Adapive Enterprise HP
						Dynamic Systems Microsoft
						
						any resources can be viewed as autonomic: storage, load balanced, app server
						
						
						problem determination and remediation, automated provisioning, work- load management,
						
						learning, stability, control and emergent be- havior in multiagent systems, and
						
						For example, a database component might need to answer what-if questions from application server middleware t
						They need models of workload so that they can forecast future demand and plan accordingly. In
						
						element’s optimization landscape is bound to change over time.	
						
						human interaction
						
						--
						beides
						
						self-configuration, self-healing, self-optimization, and self-protection
						
						self-configuration, self-optimization, self-healing, self-protection
						
						systems will manage themselves in accordance with high-level objectives specified by humans. The
						--
						
						The need to integrate several het- erogeneous environments into corporate-wide com- puting systems,
						
						looming soft- ware complexity crisis.1 The
						
						
						will maintain and adjust their operation in the face of changing components, workloads, demands, and external conditions and in the face of hardware or software failures
						
						Autonomic systems will continually seek ways to improve their operation,
						
						will defend the system as a whole against large-scale problems
						
						will anticipate problems based on early reports from sensors and take steps to avoid or mitigate them.
						
						The element may require assistance from other elements to achieve its goals
						
						high-level objectives, such as “maximize this utility function,”
						
						Second, as consumers, auto- nomic elements will autonomously and proactively issue requests to other elements to carry out their objectives.
						
						
						
						As systems become more interconnected and diverse, architects are less able to anticipate and design interactions among components, leaving such issues to be dealt with at runtime. Soon
						
						
						autonomic
						term with a biological conno- tation. The autonomic nervous system governs our heart rate and body temperature, thus freeing our conscious brain from the burden of dealing with these and many other low-leve
						

						<em>Recovery-Oriented Computing</em> (ROC) shares some of the same goals of the Autonomic Computing.  The main idea of ROC is that in large scale systems failures are evident.  In ROC the focus is in minimizing the time required to recover from failures.  As this recovery time is measurable, it can be constantly improved and optimized.  Systems must always be designed to recover from all kind of failures they encounter <cite>ROC</cite>.
						
					</pre>
				</section>


			
				<section>
					<h1>Grid Computing</h1>

					<pre>
					In the book "The Grid: Blueprint for a New Computing Infrastructure" Kesselman and Foster introduce an idea of computing power as electricity like utility.  In the vision a user could just plug computer in computer grid and applications would take use of a grid  of computers [TheGrid08]. The grid computing is usually implemented as a cluster of nodes that users can allocate and run their computations on.   As the definition of the term is vague, Foster proposes a "Grid Checklist" in his followup article [WhatIsGrid02].
				
					In the article following description for a grid system is given: <em>"Coordinates resources that are not subject to centralized control using standard, open, general-purpose protocols and interfaces to deliver nontrivial qualities of service."</em>  This can be divided into three separate parts.
					</pre>
				
					<ol>
						<li><em>"coordinates resources that are not subject to centralized control ..."</em>
							<br/>System is accessible for example, for users of different administrative units of the same company or different companies.</li>
				
						<li><em>"... using standard, open, general-purpose protocols and interfaces ..."</em>
							<br/>All protocols used in grid are open standards. Using closed or proprietary standards would mean that grid is application specific and not an utility.
						</li>
				
						<li><em>"... to deliver nontrivial qualities of service."</em>
							<br/>Grid as whole delivers various qualities of service, such as response time, availability and security so that utility of the combined system (grid) is greater than separate components that it consists of.
						</li>
					</ol>

				</section>

			</section>
		
			<section>
				<h1>Cloud Computing Paradigm</h1>

				<pre>
					Time-sharing: pay-as-you-go, expensive investment becomes cheaper due utilization rate
			
					Client-server: many clients accessing many servers, centralized data management, utilize server resources
			
					Thin-clients: different devices, computing resources on server
			
					Web software: distribution method, centralized updates
			
					SOA: service composed of many individual services, but with simple http rest
			
					Grid computing: computing as electricity, illusion of infinity
			
					Autonomic computing: self-healing systems        
		      	</pre>                     



				<section>
					<h1>Attributes of Cloud Service</h1>
		
					<pre>				
						Infinite Scaling
			
						On-demand Elastic Allocation of Resources
					
							dna-albumi
					
						Self-healing
				
						Commodity Hardware
					</pre>
			
				</section>
		
				<section>
					<h1>Components of Cloud Service</h1>

					<pre>
						XaaS and Service Oriented Architectures

						implementation levels
					
						cloud ontologies
					</pre>
				
					<section>
						<h1>Infrastucture as a Service</h1>
					</section>
		
					<section>
						<h1>Platform as a Service</h1>
					</section>
		
					<section>
						<h1>Software as a Service</h1>
					</section>

					<section>
						<h1>XaaS</h1>

						<pre>
							Datastorage as a Service

							Communications as a Service
					
							Hardware as a Service
						</pre>
					</section>
				</section>
		
				<section>
					<h1>Critic to Cloud Computing Paradigm</h1>
			
					<pre>
						"Critics of outsourcing argue that, in many instances, outsourcing can result in organizations inadvertently becoming dependent on vendors." vs Open Source
				
						"ASP applications are generally packaged, of the shelf rather than customized to the organizations business processes. ASP"
				
						"An ASP is not just for hosting applications but ensuring that the applications are maintained, monitored, scaled and upgrades effectively over time."
				
						"Security issues are likely to deter the adoption of web-enabled ASP applications."
						<cite>Licence</cite>
				
					</pre>
				</section>
			</section>
	</section>
	
	
	
	<section>
		<h1>Ye olde</h1>
		
		<pre>
		Implementing cloud, the bad parts

		CAP theorem

		Proof of CAP

		Critic to CAP theorem

		Architectural Patterns

		Old world architectures

		ACID

		Cloud compliant architectures

		BASE

		Basically Available

		Soft State

		Eventually Consistent

		BASE vs ACID

		Emerging Technology

		Measuring Cloud Services

		TPC-C Like Traditional Measurement wont do

		Requirements for Cloud Measurement

		Measurement techniques

		YCBS Benchmarking

		Identifying Common X,Y,Z Requirements for Cloud Services

		Implementing X, Y, Z

		Evaluation of X, Y, Z
		
		</pre>
		
		</section>
		
      	<section>
			<h1>Conclusions</h1>
			
			<pre>
				none.
			</pre>
		</section>
		
		
		
    </article>
    
    
    
    <article class="references">
		<h1>References</h1>

		<section>
			<p><abbr data-lattex="autonomic_research">autonomic_research</abbr> Kephart J. Research challenges of autonomic computing. Proceedings. 27th International Conference on Software Engineering, 2005. ICSE 2005. 2005:15-22. Available at: http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1553533.</p>
		</section>	
		
		<section>
			<abbr data-lattex="autonomic_vision">autonomic_vision</abbr>
			
			<p>Kephart J, Chess D. The vision of autonomic computing. Computer. 2003;(January):41-50. Available at: http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1160055.</p>
		</section>
		

		<section>
			<abbr data-lattex="ROC">ROC</abbr>
			
			<p>Fox A. Toward recovery-oriented computing. Proceedings of the 28th VLDB Conference. 2002. Available at: http://portal.acm.org/citation.cfm?id=1287443.</p>
		</section>
		
		<section>
			<abbr data-lattex="vogels">Vogels</abbr>
			<p>O'Hanlon C. A conversation with Werner Vogels. Queue. Volume 4,  Issue 4 May 2006. Available at: http://portal.acm.org/citation.cfm?id=1142065.</p>
		</section>
		
		<section>
			<abbr data-lattex="zuse">Cer81</abbr>
			
			<p>Ceruzzi P. The early computers of Konrad Zuse, 1935 to 1945. Annals of the History of Computing. 2008;3(3). Available at: http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4640687.</p>	
		</section>

		<section>
			<abrr data-lattex="Ethernet">MBo76</abrr>
			
			<p>Metcalfe R, Boggs D. Ethernet: Distributed packet switching for local computer networks. Communications of the ACM. 1976;19(7). Available at: http://portal.acm.org/citation.cfm?id=360248.360253.</p>
			
		</section>

		<section>
			<abrr data-lattex="asp">ASP</abrr>
			
			<p>Patnayakuni R, Seth N. Why license when you can rent? Risks and rewards of the application service provider model. Proceedings of the 2001 ACM SIGCPR conference on Computer personnel research - SIGCPR '01. 2001:182-188. Available at: http://portal.acm.org/citation.cfm?doid=371209.371233.</p>
			
		</section>
		<section>
			<abbr data-lattex="YCBS10">YCBS10</abbr>
	
			<p>Cooper BF, Silberstein A, Tam E, Ramakrishnan R, Sears R. Benchmarking cloud serving systems with YCSB. Proceedings of the 1st ACM symposium on Cloud computing - SoCC '10. 2010:143. Available at: http://portal.acm.org/citation.cfm?doid=1807128.1807152.</p>
		</section>

		<section>
			<abbr data-lattex="WhatsInside09">WhatsInside09</abbr>
			
			<p>Lenk A, Klems M, Nimis J, Tai S, Sandholm T. What's inside the Cloud? An architectural map of the Cloud landscape. 2009 ICSE Workshop on Software Engineering Challenges of Cloud Computing. 2009:23-31. Available at: http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5071529.</p>
		</section>
		
		<section>
			<abbr data-lattex="CloudComputing08">CloudComputing08</abbr>
	     	
			<p>Hayes B. Cloud computing. Communications of the ACM. 2008;51(7):9. Available at: http://portal.acm.org/citation.cfm?doid=1364782.1364786.</p>
		</section>
		
		<section>
			<abbr data-lattex="TimeSharing64">TimeSharing64</abbr>
	    
			<p>Schwartz J, Coffman E, Weissman C. A general-purpose time-sharing system. of the April 21-23, 1964,. 1964:397. Available at: http://portal.acm.org/citation.cfm?id=1464163.</p>
		</section>
		
		<section>
			<abbr data-lattex="ClientServer96">ClientServer96</abbr>
			
	    	<p>Franklin MJ, Jónsson BT, Kossmann D. Performance tradeoffs for client-server query processing. ACM SIGMOD Record. 1996;25(2):149-160. Available at: http://portal.acm.org/citation.cfm?doid=235968.233328.</p>
		</section>
		
		<section>
			<abbr data-lattex="InTheClouds07">InTheClouds07</abbr>
	    
			<p>Weiss A. Computing in the clouds. netWorker. 2007;11:16-25. Available at: http://portal.acm.org/citation.cfm?doid=1327512.1327513.</p>
		</section>
		
		<section>
			<abbr data-lattex="Cusumano10">Cusumano10</abbr>
	﻿       
			<p>Cusumano M. Cloud computing and SaaS as new computing platforms. Communications of the ACM. 2010;53(4):27. Available at: http://portal.acm.org/citation.cfm?doid=1721654.1721667.</p>
		</section>
		
		<section>
			<abbr data-lattex="WhatIsGrid02">WhatIsGrid02</abbr>
	        <p>Foster I. What is the grid? a three point checklist. GRID today. 2002.</p>
		</section>
		
		<section>
			<abbr data-lattex="TheGrid08">TheGrid08</abbr>
	        
			<p>Kesselman, C. &amp; Foster, I. The Grid: Blueprint for a New Computing Infrastructure (Morgan Kaufmann Publishers, 1998). URL http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&amp;path=ASIN/1558604758.</p>
		</section>
	

        
    </article>
  


    <footer>
      <span data-lattex="pagenumber"></span>  <span>&copy; pottisheads</span>
    </footer>
    

  </body>

</html>
